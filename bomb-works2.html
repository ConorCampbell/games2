
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plane Bombing Game</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
        }
        #game-container {
            position: relative;
            background-color: #334155; /* Darker background for game area */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            width: 90%; /* Responsive width */
            max-width: 800px; /* Max width for desktop */
            height: 90vh; /* Responsive height */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            /* Added for 3D perspective */
            perspective: 1000px; /* Defines the depth of the 3D scene */
        }
        #score-display {
            background-color: #cbd5e1; /* Light gray */
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            color: #1a202c;
            text-align: center;
            width: 100%;
            margin-bottom: 10px;
            z-index: 2; /* Ensure score is above map and canvas */
            position: relative;
        }

        #map-canvas-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Allow container to grow and take available space */
            border-radius: 10px;
            overflow: hidden; /* Ensure map stays within bounds */
            /* Added for 3D rotation */
            /* Tilt the map 45 degrees back */
             transform: rotateX(45deg);
            transform-origin: center bottom; /* Rotate from the bottom center */
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7); /* Add shadow for depth */
        }

        #leaflet-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Behind canvas */
        }

        canvas {
            background-color: transparent; /* Make canvas transparent to show map */
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Above map for drawing */
            pointer-events: none; /* Crucial: Allows clicks to pass through to map underneath */
        }

        #game-input-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* On top of canvas to capture events */
        }
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 15px; /* Match game container radius */
        }
        .modal-content {
            background-color: #f7fafc; /* White */
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .modal-content h2 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            color: #2d3748;
        }
        .modal-content p {
            margin-bottom: 10px;
            color: #4a5568;
        }
        .modal-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .modal-buttons button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .modal-buttons button:hover {
            background-color: #3182ce; /* Darker blue */
            transform: translateY(-2px);
        }
        .modal-buttons button:active {
            transform: translateY(0);
            box-shadow: none;
        }
        .llm-output {
            background-color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-style: italic;
            color: #2d3748;
            text-align: left;
            max-width: 500px;
            width: 100%;
            overflow-y: auto;
            max-height: 150px;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Ensure the hidden class truly hides elements */
        .hidden {
            display: none !important;
        }

        /* Custom marker icon for targets */
        .target-icon {
            background-color: #10b981; /* Green */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            border: 2px solid #047857;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            text-align: center;
        }

        .target-icon.target-hit, .crater-marker {
            /* Fire-like animated background using multiple gradients */
            /* position: relative; */
            background:
                radial-gradient(circle at 60% 40%, #fffbe6 0%, #ffe066 30%, transparent 70%),
                radial-gradient(circle at 40% 70%, #ffb347 0%, #ff8300 60%, transparent 90%),
                radial-gradient(circle at 70% 80%, #ff6a00 0%, #ff2e00 60%, transparent 90%),
                radial-gradient(circle at 30% 20%, #ffd700 0%, #ff9100 50%, transparent 90%);
            border: 2px solid #ff9100;
            color: #fff;
            box-shadow:
                0 0 16px 8px rgba(255, 140, 0, 0.6),
                0 0 32px 16px rgba(255, 69, 0, 0.4),
                0 0 48px 24px rgba(255, 0, 0, 0.2);
            animation-iteration-count: 3;
            animation: fire-flicker 0.5s alternate;
            overflow: visible;
        }

        @keyframes fire-flicker {
            0% {
                filter: brightness(1.1) blur(0.5px);
                box-shadow:
                    0 0 16px 8px rgba(255, 140, 0, 0.7),
                    0 0 32px 16px rgba(255, 69, 0, 0.5),
                    0 0 48px 24px rgba(255, 0, 0, 0.25);
                /* transform: scale(1) rotate(-2deg); */
            }
            40% {
                filter: brightness(1.3) blur(1.2px);
                box-shadow:
                    0 0 24px 12px rgba(255, 180, 0, 0.8),
                    0 0 40px 20px rgba(255, 100, 0, 0.6),
                    0 0 60px 30px rgba(255, 0, 0, 0.3);
                /* transform: scale(1.04) rotate(2deg); */
            }
            70% {
                filter: brightness(1.2) blur(0.7px);
                box-shadow:
                    0 0 20px 10px rgba(255, 160, 0, 0.7),
                    0 0 36px 18px rgba(255, 80, 0, 0.5),
                    0 0 54px 27px rgba(255, 0, 0, 0.22);
                /* transform: scale(0.98) rotate(-1deg); */
            }
            100% {
                filter: brightness(1.05) blur(0.3px);
                box-shadow:
                    0 0 14px 7px rgba(255, 120, 0, 0.6),
                    0 0 28px 14px rgba(255, 50, 0, 0.4),
                    0 0 42px 21px rgba(255, 0, 0, 0.18);
                /* transform: scale(1.02) rotate(1deg); */
            }
        }


        .target-icon.target-hit::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 350%; /* Make smoke larger than crater */
            height: 550%;

            /*background-color: rgba(120, 120, 120, 0.92);*/

            /* background: radial-gradient(circle, rgba(180, 180, 180, 0.983) 0%, rgba(200, 200, 200, .25) 95%); */

            background: radial-gradient(circle, rgba(80, 80, 80, 0.98) 0%, rgba(60, 60, 60, 0.7) 60%, rgba(120, 120, 120, 0.25) 95%);

            border-radius: 50%;

            transform: translate(-50%, -50%);
            animation-iteration-count: 2;
            animation: smoke-puff 3s ease-out forwards ;
        }


        /* --- NEW: CSS for Crater and Smoke Effect --- */
        .crater-marker {
            /* Dark brown for crater */
            /* background-color: rgba(20, 10, 5, 0.2);  */
            border-radius: 50%;
            /* border: 1px solid #87373771; */
            /* position: relative; */
            /* box-shadow: inset 0 0 8px rgba(235, 223, 62, 0.8); */
            animation: fade-out 2s ease-out forwards ;
        }

        @keyframes fade-out {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 1;
                background-color: rgba(180, 82, 33, 0.5);
                border:brown;
                background: none;
                box-shadow: none;
            }
        }

        .crater-marker::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 250%; /* Make smoke larger than crater */
            height: 450%;
            background: radial-gradient(circle, rgba(200, 200, 180, 0.7) 0%, rgba(220, 220, 200, 0) 95%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: smoke-puff 8s ease-out ;
            opacity: 0;

        }

        @keyframes smoke-puff {
            0% {
                transform: translate(-50%, -50%) scale(0.2);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -90%) scale(0.3);
                opacity: .5;
            }
            75% {
                transform: translate(-50%, -120%) scale(1);
                opacity: .5;
            }
            98% {
                transform: translate(-50%, -150%) scale(1.55);
                opacity: .3;
            }
            100% {
                transform: translate(-50%, -150%) scale(0);
                opacity: 0;
                background:none
            }

        }
        /* --- END NEW CSS --- */


        /* Custom Zoom Controls Styling */
        .custom-zoom-button {
            background-color: rgba(45, 55, 72, 0.8); /* Semi-transparent dark gray */
            border: 2px solid rgba(255, 255, 255, 0.5);
            transition: background-color 0.2s;
        }
        .custom-zoom-button:hover {
            background-color: rgba(74, 85, 104, 0.9); /* Lighter on hover */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen bg-gray-900">
    <div id="game-container" class="relative">
        <div id="score-display">Score: 0 | Hits: 0 | Misses: 0</div>
        <div id="map-canvas-container">
            <div id="leaflet-map"></div>
            <canvas id="gameCanvas"></canvas>
            <div id="game-input-overlay"></div>

            <div id="custom-zoom-controls" class="absolute  bottom-2 -translate-y-1/2 flex flex-col items-center space-y-2" style="z-index: 3;">
                <button id="custom-zoom-out" class="custom-zoom-button text-white font-bold rounded-full w-12 h-12 flex items-center justify-center text-2xl shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="m18 15-6-6-6 6"/></svg>
                </button>
                <button id="custom-zoom-in" class="custom-zoom-button text-white font-bold rounded-full w-12 h-12 flex items-center justify-center text-2xl shadow-lg">
                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                </button>
            </div>
        </div>

        <div id="areaSelectionModal" class="modal">
            <div class="modal-content">
                <h2>Select Your Target Area</h2>
                <p id="areaSelectionDescription">Choose an area to fly over and bomb targets. Longer maps offer more challenges and potential points!</p>
                <div id="areaSelectionButtonsContainer" class="modal-buttons grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>

                <div id="actionButtonsContainer" class="flex flex-col items-center gap-4 hidden">
                    <button id="getBriefingButton" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg mt-4">
                        Get Mission Briefing ✨ <span id="briefingLoading" class="hidden loading-spinner"></span>
                    </button>
                    <div id="missionBriefingOutput" class="llm-output hidden"></div>

                    <button id="finalStartGameButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg mt-4">
                        Start Mission!
                    </button>
                </div>
            </div>
        </div>

        <div id="gameOverModal" class="modal hidden">
            <div class="modal-content">
                <h2 id="gameOverTitle">Game Over!</h2>
                <p id="finalScore">Final Score: 0</p>
                <p id="proximityResults">Hits: 0 | Misses: 0</p>
                <button id="getDebriefingButton" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg mt-4">
                    Get Debriefing ✨ <span id="debriefingLoading" class="hidden loading-spinner"></span>
                    </button>
                <div id="debriefingOutput" class="llm-output hidden"></div>
                <div class="modal-buttons mt-4">
                    <button id="restartGameButton">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

    <script>

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameInputOverlay = document.getElementById('game-input-overlay');
        const scoreDisplay = document.getElementById('score-display');
        const areaSelectionModal = document.getElementById('areaSelectionModal');
        const areaSelectionButtonsContainer = document.getElementById('areaSelectionButtonsContainer');
        const actionButtonsContainer = document.getElementById('actionButtonsContainer');
        const getBriefingButton = document.getElementById('getBriefingButton');
        const briefingLoadingSpinner = document.getElementById('briefingLoading');
        const missionBriefingOutput = document.getElementById('missionBriefingOutput');
        const finalStartGameButton = document.getElementById('finalStartGameButton');

        const gameOverModal = document.getElementById('gameOverModal');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const finalScoreDisplay = document.getElementById('finalScore');
        const proximityResultsDisplay = document.getElementById('proximityResults');
        const getDebriefingButton = document.getElementById('getDebriefingButton');
        const debriefingLoadingSpinner = document.getElementById('debriefingLoading');
        const debriefingOutput = document.getElementById('debriefingOutput');
        const restartGameButton = document.getElementById('restartGameButton');

        let animationFrameId;
        let map; // Global Leaflet map instance


        // --- Sound Effects ---
        let baseDir = "/Users/conor/Documents/Python%20Scripts/NewSite/ff"
        //let baseDir = "https://fatfinger.pythonanywhere.com"

        const bombDropSound = new Audio(`${baseDir}/static/sound/bomb-dropping.mp3`);
        bombDropSound.volume = 1; // Adjust volume to not be too loud

        const explosionSound = new Audio(`${baseDir}/static/sound/explosion-8-bit.mp3`);
        explosionSound.volume = 0.4;

        function playSound(sound) {
            sound.currentTime = 0; // Rewind to the start
            sound.play();
        }
        // --- END SOUND ---

        // Touch control variables
        let touchStartInitialY = 0;
        let touchLastMoveY = 0;
        let touchCurrentY = 0;
        let touchIsActive = false;

        const TOUCH_MOVE_THRESHOLD = 5;
        const TOUCH_TAP_MAX_DURATION = 300;
        let touchStartTime = 0;

        // Game State Variables
        const GAME_STATES = { START: 'start', PLAYING: 'playing', GAME_OVER: 'gameOver' };
        let currentGameState = GAME_STATES.START;

        // Game Constants
        const INITIAL_PLANE_WIDTH = 45;
        const INITIAL_PLANE_HEIGHT = 20;

        const INITIAL_BOMB_WIDTH = 8;
        const INITIAL_BOMB_HEIGHT = 16;

        const PLANE_SPEED_Y = 5;
        const BOMB_GRAVITY = 0.05;
        const MAP_SCROLL_SPEED_METERS_PER_FRAME = 10;

        const BASE_GROUND_OFFSET_Y = 150;
        let dynamicGroundOffsetY = BASE_GROUND_OFFSET_Y;
        const EXPLOSION_DURATION = 30;

        const PLANE_TILT_MAX_ANGLE = 25 * (Math.PI / 180);
        const PLANE_TILT_SPEED_FACTOR = 1.5;

        // Game Objects
        let plane = { x: 100, y: 0, width: INITIAL_PLANE_WIDTH, height: INITIAL_PLANE_HEIGHT, tiltAngle: 0, targetTiltAngle: 0 };
        let bombs = [];
        let activeTargets = [];
        let lastTargetLng = -Infinity; // To store the longitude of the rightmost target

        let BASE_ZOOM_FOR_GROUND_OFFSET;
        let planeGeoLocation;

        let explosions = [];

        let score = 0;
        let hits = 0;
        let misses = 0;
        let mapScrollXProgress = 0;
        // totalMapLength is no longer used for game end condition, but kept for area description
        let totalMapLength = 0;
        let selectedGameArea = null;


    // set a difficulty level from 1-5
        let difficulty = 8


const gameAreas = [
    // ✅ Existing - New York
    {
        name: "Urban Sprawl",
        description: "Dense city, many targets but challenging to navigate.",
        mapLength: 6000,
        fixedLatitude: 40.7500,
        initialCenterLng: -74.0500,
        longitudinalSpan: 0.1,
        zoom: 14,
        targetLatLngs: [
            { lat: 40.7550, lng: -74.0200, radiusMeters: 100, basePoints: 150 },
            { lat: 40.7450, lng: -74.0000, radiusMeters: 150, basePoints: 120 },
            { lat: 40.7600, lng: -73.9800, radiusMeters: 120, basePoints: 130 },
            { lat: 40.7400, lng: -73.9600, radiusMeters: 180, basePoints: 110 },
            { lat: 40.7580, lng: -73.9400, radiusMeters: 110, basePoints: 140 },
            { lat: 40.7480, lng: -73.9200, radiusMeters: 160, basePoints: 125 },
            { lat: 40.7620, lng: -73.9000, radiusMeters: 130, basePoints: 135 },
            { lat: 40.7520, lng: -73.8800, radiusMeters: 190, basePoints: 115 }
        ]
    },

    // ✅ Existing - London
    {
        name: "The Gauntlet",
        description: "Extreme length and target density. For pros only! The ultimate test.",
        mapLength: 32000,
        fixedLatitude: 51.5000,
        initialCenterLng: -0.2000,
        longitudinalSpan: 0.15,
        zoom: 14,
        targetLatLngs: [
            { lat: 51.5020, lng: -0.1900, radiusMeters: 100, basePoints: 200 },
            { lat: 51.4980, lng: -0.1800, radiusMeters: 180, basePoints: 180 },
            { lat: 51.5030, lng: -0.1700, radiusMeters: 130, basePoints: 190 },
            { lat: 51.4970, lng: -0.1600, radiusMeters: 220, basePoints: 170 },
            { lat: 51.5010, lng: -0.1500, radiusMeters: 150, basePoints: 195 },
            { lat: 51.4960, lng: -0.1400, radiusMeters: 250, basePoints: 165 },
            { lat: 51.5040, lng: -0.1300, radiusMeters: 170, basePoints: 188 },
            { lat: 51.4990, lng: -0.1200, radiusMeters: 280, basePoints: 162 },
            { lat: 51.5050, lng: -0.1100, radiusMeters: 190, basePoints: 192 },
            { lat: 51.4950, lng: -0.1000, radiusMeters: 300, basePoints: 168 },
            { lat: 51.5000, lng: -0.0900, radiusMeters: 200, basePoints: 185 },
            { lat: 51.4900, lng: -0.0800, radiusMeters: 320, basePoints: 158 },
            { lat: 51.4850, lng: -0.0700, radiusMeters: 350, basePoints: 150 }
        ]
    },

    // ✅ New Cities with proper longitude spread


    {
        name: "Tricky Tokyo Trail",
        description: "A high-speed run through the heart of Tokyo, threading between skyscrapers.",
        mapLength: 10000,
        fixedLatitude: 35.6895,
        initialCenterLng: 139.6000,
        longitudinalSpan: 0.3,
        zoom: 14,
        targetLatLngs: Array.from({ length: 12 }, (_, i) => ({

            lat: 35.6895 + ((Math.random() - 0.5) * 0.005 * difficulty),

            lng: 139.6000 + (i * 0.015 -(difficulty * .00275)) +  (0.035 + (difficulty * 0.01) * Math.random()),

            radiusMeters: 200 - (10*difficulty) + Math.random() * (200 - 10 *difficulty),

            basePoints: 100 + Math.floor(Math.random() * 100)
        }))
    },
    {
        name: "Paris Dash",
        description: "Fly low across Parisian rooftops, hitting targets along the Seine.",
        mapLength: 9000,
        fixedLatitude: 48.8566,
        initialCenterLng: 2.2500,
        longitudinalSpan: 0.25,
        zoom: 14,
        targetLatLngs: Array.from({ length: 11 }, (_, i) => ({
            lat: 48.8566 + (Math.random() - 0.5) * 0.01,
            lng: 2.2500 + i * 0.022,
            radiusMeters: 140 + Math.random() * 90,
            basePoints: 110 + Math.floor(Math.random() * 90)
        }))
    },
    {
        name: "São Paulo Run",
        description: "A chaotic flight path through Brazil's largest city—watch for tight turns.",
        mapLength: 11000,
        fixedLatitude: -23.5505,
        initialCenterLng: -46.7000,
        longitudinalSpan: 0.35,
        zoom: 14,
        targetLatLngs: Array.from({ length: 13 }, (_, i) => ({
            lat: -23.5505 + (Math.random() - 0.5) * 0.012,
            lng: -46.7000 + i * 0.028,
            radiusMeters: 160 + Math.random() * 120,
            basePoints: 100 + Math.floor(Math.random() * 120)
        }))
    },
    {
        name: "Cairo Rush",
        description: "Ancient meets modern in this eastbound streak across Cairo.",
        mapLength: 9500,
        fixedLatitude: 30.0444,
        initialCenterLng: 31.1500,
        longitudinalSpan: 0.3,
        zoom: 14,
        targetLatLngs: Array.from({ length: 12 }, (_, i) => ({
            lat: 30.0444 + (Math.random() - 0.5) * 0.01,
            lng: 31.1500 + i * 0.025,
            radiusMeters: 140 + Math.random() * 110,
            basePoints: 105 + Math.floor(Math.random() * 100)
        }))
    },
    {
        name: "Sydney Skim",
        description: "Coastal cliffs and harbor bridges—precision required!",
        mapLength: 10000,
        fixedLatitude: -33.8688,
        initialCenterLng: 151.1000,
        longitudinalSpan: 0.35,
        zoom: 14,
        targetLatLngs: Array.from({ length: 12 }, (_, i) => ({
            lat: -33.8688 + (Math.random() - 0.5) * 0.01,
            lng: 151.1000 + i * 0.03,
            radiusMeters: 130 + Math.random() * 100,
            basePoints: 115 + Math.floor(Math.random() * 90)
        }))
    },
    {
        name: "Mumbai Blitz",
        description: "A fast-paced challenge through India's economic capital.",
        mapLength: 10000,
        fixedLatitude: 19.0760,
        initialCenterLng: 72.8000,
        longitudinalSpan: 0.3,
        zoom: 14,
        targetLatLngs: Array.from({ length: 11 }, (_, i) => ({
            lat: 19.0760 + (Math.random() - 0.5) * 0.012,
            lng: 72.8000 + i * 0.027,
            radiusMeters: 150 + Math.random() * 90,
            basePoints: 100 + Math.floor(Math.random() * 100)
        }))
    },
    {
        name: "Toronto Glide",
        description: "Smooth, scenic route across downtown and beyond.",
        mapLength: 9500,
        fixedLatitude: 43.6532,
        initialCenterLng: -79.5000,
        longitudinalSpan: 0.3,
        zoom: 14,
        targetLatLngs: Array.from({ length: 11 }, (_, i) => ({
            lat: 43.6532 + (Math.random() - 0.5) * 0.02,
            lng: -79.5000 + i * 0.022 + (Math.random() - 0.5) * 0.018,
            radiusMeters: 140 + Math.random() * 125,
            basePoints: 100 + Math.floor(Math.random() * 120)
        }))
    }
];


        // --- Map Initialization ---
        // --- Input Handling ---
        let keysPressed = {};
        document.addEventListener('keydown', (e) => {
            if (currentGameState === GAME_STATES.PLAYING) {
                // Prevent default scrolling behavior for arrow keys and spacebar
                if (['ArrowUp', 'ArrowDown', 'Space'].includes(e.code)) { e.preventDefault(); }
                if (e.code === 'Space' && !keysPressed['Space']) {
                    // Limit bombs to 3 at a time for strategic drops
                    if (bombs.length < 3) {
                        playSound(bombDropSound); // Play sound on drop

                        bombs.push({ x: plane.x + plane.width / 2 - INITIAL_BOMB_WIDTH / 2, originalY:plane.y, y: plane.y + plane.height, width: INITIAL_BOMB_WIDTH, height: INITIAL_BOMB_HEIGHT, velocityY: 0 });

                    }
                }
            }
            keysPressed[e.code] = true;
        });
        document.addEventListener('keyup', (e) => { keysPressed[e.code] = false; });

        // Touch event listeners for mobile input
        gameInputOverlay.addEventListener('touchstart', (e) => {
            // Temporarily disable pointer events to determine if the touch is on a Leaflet control
            gameInputOverlay.style.pointerEvents = 'none';
            const targetElement = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
            gameInputOverlay.style.pointerEvents = 'auto'; // Re-enable pointer events

            // If the touch is on a Leaflet control or custom zoom button, do not process as game input
            if (targetElement && (targetElement.closest('.leaflet-control') || targetElement.closest('.custom-zoom-button'))) {
                touchIsActive = false; // Mark touch as inactive for game control
                return;
            }

            // Only process if in playing state and a single touch
            if (currentGameState === GAME_STATES.PLAYING && e.touches.length === 1) {
                touchStartInitialY = e.touches[0].pageY; // Record initial Y position
                touchLastMoveY = e.touches[0].pageY;    // Initialize last move Y
                touchCurrentY = e.touches[0].pageY;     // Initialize current Y
                touchIsActive = true;                   // Activate touch control flag
                touchStartTime = Date.now();            // Record touch start time for tap detection
                e.preventDefault();                     // Prevent default touch behaviors like scrolling
            }
        });

        gameInputOverlay.addEventListener('touchmove', (e) => {
            // Temporarily disable pointer events to determine if the touch is on a Leaflet control
            gameInputOverlay.style.pointerEvents = 'none';
            const targetElement = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
            gameInputOverlay.style.pointerEvents = 'auto'; // Re-enable pointer events

            // If the touch is on a Leaflet control or custom zoom button, do not process as game input
            if (targetElement && (targetElement.closest('.leaflet-control') || targetElement.closest('.custom-zoom-button'))) {
                touchIsActive = false; // Mark touch as inactive for game control
                return;
            }

            // Only process if in playing state, a single touch, and touch is active for game
            if (currentGameState === GAME_STATES.PLAYING && e.touches.length === 1 && touchIsActive) {
                touchCurrentY = e.touches[0].pageY; // Update current Y position
                e.preventDefault();                 // Prevent default touch behaviors
            }
        });

        gameInputOverlay.addEventListener('touchend', (e) => {
            // Get client coordinates, handling both touch and mouse for robustness
            const clientX = e.changedTouches[0] ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches[0] ? e.changedTouches[0].clientY : e.clientY;

            // Temporarily disable pointer events to determine if the touch is on a Leaflet control
            gameInputOverlay.style.pointerEvents = 'none';
            const targetElement = document.elementFromPoint(clientX, clientY);
            gameInputOverlay.style.pointerEvents = 'auto'; // Re-enable pointer events

            const wasTouchActiveForGame = touchIsActive; // Store state before resetting
            const touchDuration = Date.now() - touchStartTime; // Calculate touch duration
            const finalTouchYPosition = e.changedTouches[0] ? e.changedTouches[0].pageY : touchCurrentY;
            const totalTouchMovement = Math.abs(finalTouchYPosition - touchStartInitialY);

            // Reset touch state variables
            touchIsActive = false;
            touchStartInitialY = 0;
            touchLastMoveY = 0;
            touchCurrentY = 0;
            touchStartTime = 0;

            // Check if it was a tap (minimal movement, short duration) to drop a bomb
            if (currentGameState === GAME_STATES.PLAYING && wasTouchActiveForGame) {
                if (totalTouchMovement < TOUCH_MOVE_THRESHOLD && touchDuration < TOUCH_TAP_MAX_DURATION) {
                    if (bombs.length < 3) { // Limit bombs
                        playSound(bombDropSound); // Play sound on drop
                        bombs.push({ x: plane.x + plane.width / 2 - INITIAL_BOMB_WIDTH / 2, originalY:plane.y , y: plane.y + plane.height, width: INITIAL_BOMB_WIDTH, height: INITIAL_BOMB_HEIGHT, velocityY: 0 });
                        // bombs.push({ x: plane.x + plane.width / 2 - INITIAL_BOMB_WIDTH / 2, y: plane.y + plane.height, width: INITIAL_BOMB_WIDTH, height: INITIAL_BOMB_HEIGHT, velocityY: 0 });
                    }
                }
            }
        });

        // Click listener for bomb dropping (for desktop)
        gameInputOverlay.addEventListener('click', (e) => {
            // Temporarily disable pointer events to determine if the click is on a Leaflet control
            gameInputOverlay.style.pointerEvents = 'none';
            const targetElement = document.elementFromPoint(e.clientX, e.clientY);
            gameInputOverlay.style.pointerEvents = 'auto'; // Re-enable pointer events

            // If the click is on a Leaflet control or custom zoom button, do not process as game input
            if (targetElement && (targetElement.closest('.leaflet-control') || targetElement.closest('.custom-zoom-button'))) {
                return;
            }

            if (currentGameState === GAME_STATES.PLAYING) {
                if (bombs.length < 3) { // Limit bombs
                    playSound(bombDropSound); // Play sound on drop
                    bombs.push({ x: plane.x + plane.width / 2 - INITIAL_BOMB_WIDTH / 2, originalY:plane.y , y: plane.y + plane.height, width: INITIAL_BOMB_WIDTH, height: INITIAL_BOMB_HEIGHT, velocityY: 0 });
                    // bombs.push({ x: plane.x + plane.width / 2 - INITIAL_BOMB_WIDTH / 2, y: plane.y + plane.height, width: INITIAL_BOMB_WIDTH, height: INITIAL_BOMB_HEIGHT, velocityY: 0 });
                }
            }
        });

        /**
         * Calls the Gemini API to generate text based on a prompt.
         * Displays the output in the specified element and manages a loading spinner.
         * @param {string} prompt - The text prompt for the API.
         * @param {HTMLElement} outputElement - The HTML element to display the API response.
         * @param {HTMLElement} loadingSpinnerElement - The HTML element for the loading spinner.
         */
        async function callGeminiAPI(prompt, outputElement, loadingSpinnerElement) {
            outputElement.classList.add('hidden'); // Hide previous output
            outputElement.textContent = ''; // Clear previous output
            loadingSpinnerElement.classList.remove('hidden'); // Show loading spinner
            try {
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiKey = ""; // API key is provided by the Canvas environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();

                // Check for valid response structure
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    outputElement.textContent = text;
                    outputElement.classList.remove('hidden'); // Show the output
                } else {
                    outputElement.textContent = "Failed to get a response from Gemini.";
                    outputElement.classList.remove('hidden'); // Show the output with error
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                outputElement.textContent = `Error: ${error.message}. Please try again.`;
                outputElement.classList.remove('hidden'); // Show the output with error
            } finally {
                loadingSpinnerElement.classList.add('hidden'); // Hide loading spinner
            }
        }

        /**
         * Initializes the game state, UI, and event listeners.
         * This function is called on window load and when restarting the game.
         */

        function initGame() {

            // Hide all modals initially
            hideModal(areaSelectionModal);
            hideModal(gameOverModal);

            // Set canvas and overlay dimensions to match their container
            const mapCanvasContainer = document.getElementById('map-canvas-container');
            canvas.width = mapCanvasContainer.clientWidth;
            canvas.height = mapCanvasContainer.clientHeight;
            gameInputOverlay.style.width = mapCanvasContainer.clientWidth + 'px';
            gameInputOverlay.style.height = mapCanvasContainer.clientHeight + 'px';

            // Reset plane position and tilt
            plane.y = canvas.height / 2 - plane.height / 2;
            plane.tiltAngle = 0;
            plane.targetTiltAngle = 0;

            // Clear and hide mission briefing related elements
            missionBriefingOutput.textContent = '';
            missionBriefingOutput.classList.add('hidden');
            briefingLoadingSpinner.classList.add('hidden');
            actionButtonsContainer.classList.add('hidden'); // Hide briefing/start game buttons

            // Reset selected area button styles
            areaSelectionButtonsContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('bg-green-500', 'hover:bg-green-600'));
            // Reset area description
            document.getElementById('areaSelectionDescription').textContent = "Choose an area to fly over and bomb targets. Longer maps offer more challenges and potential points!";

            // Render the game area selection buttons
            renderAreaSelection();
            showModal(areaSelectionModal); // Show the area selection modal

            currentGameState = GAME_STATES.START; // Set game state to start

            // Event listener for restarting the game
            restartGameButton.onclick = () => {
                hideModal(gameOverModal); // Hide game over modal
                debriefingOutput.textContent = ''; // Clear debriefing output
                debriefingOutput.classList.add('hidden');
                initGame(); // Re-initialize the game
            };

            // Event listener for getting mission briefing from Gemini API
            getBriefingButton.onclick = () => {
                if (selectedGameArea) {
                    const prompt = `Generate a short, creative, and dramatic mission briefing for a bombing run over a game area named '${selectedGameArea.name}' described as '${selectedGameArea.description}'. Focus on the challenge and objective. Keep it under 100 words.`;
                    callGeminiAPI(prompt, missionBriefingOutput, briefingLoadingSpinner);
                } else {
                    missionBriefingOutput.textContent = "Please select an area first to get a briefing.";
                    missionBriefingOutput.classList.remove('hidden');
                }
            };

            // Event listener for finally starting the game after area selection
            finalStartGameButton.onclick = () => {
                if (selectedGameArea) {
                    const areaIndex = gameAreas.findIndex(area => area.name === selectedGameArea.name);
                    startGame(areaIndex);
                }
            };

            // Responsive canvas and map resizing
            window.addEventListener('resize', () => {
                const mcContainer = document.getElementById('map-canvas-container');
                canvas.width = mcContainer.clientWidth;
                canvas.height = mcContainer.clientHeight;
                gameInputOverlay.style.width = mcContainer.clientWidth + 'px';
                gameInputOverlay.style.height = mcContainer.clientHeight + 'px';
                if (map) { map.invalidateSize(); } // Invalidate Leaflet map size on window resize
                plane.y = Math.min(Math.max(0, plane.y), canvas.height - plane.height); // Keep plane within bounds
            });
        }

        /**
         * Renders the buttons for selecting game areas in the modal.
         */
        function renderAreaSelection() {
            areaSelectionButtonsContainer.innerHTML = ''; // Clear existing buttons
            gameAreas.forEach((area, index) => {
                const button = document.createElement('button');
                button.textContent = `${area.name} (${(area.mapLength / 100).toFixed(1)}km)`; // Display name and length
                button.title = area.description; // Tooltip for description
                button.onclick = () => {
                    selectedGameArea = area; // Set the selected game area
                    // Remove selected styling from all buttons
                    areaSelectionButtonsContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('bg-green-500', 'hover:bg-green-600'));
                    // Add selected styling to the clicked button
                    button.classList.add('bg-green-500', 'hover:bg-green-600');
                    document.getElementById('areaSelectionDescription').textContent = `You've selected: ${area.name}. ${area.description}`;
                    // Clear and hide briefing output when a new area is selected
                    missionBriefingOutput.textContent = '';
                    missionBriefingOutput.classList.add('hidden');
                    actionButtonsContainer.classList.remove('hidden'); // Show briefing/start game buttons
                };
                areaSelectionButtonsContainer.appendChild(button); // Add button to container
            });
        }

        /**
         * Starts the game with the selected area.
         * @param {number} areaIndex - The index of the selected game area in `gameAreas` array.
         */
        function startGame(areaIndex) {
            hideModal(areaSelectionModal); // Hide the area selection modal
            currentGameState = GAME_STATES.PLAYING; // Set game state to playing

            // Reset game variables
            score = 0; hits = 0; misses = 0;
            mapScrollXProgress = 0;
            bombs = []; activeTargets = []; explosions = [];
            plane.tiltAngle = 0; plane.targetTiltAngle = 0;
            plane.width = INITIAL_PLANE_WIDTH; plane.height = INITIAL_PLANE_HEIGHT;
            updateScoreDisplay();

            selectedGameArea = gameAreas[areaIndex];
            totalMapLength = selectedGameArea.mapLength; // Still used for description, not end condition
            plane.x = canvas.width / 5; // Initial horizontal position of the plane

            BASE_ZOOM_FOR_GROUND_OFFSET = selectedGameArea.zoom;

            selectedGameArea.initialCenterLng = selectedGameArea.initialCenterLng - .025

            // Initialize or re-initialize Leaflet map
            if (map) { map.remove(); } // Remove existing map if any
            map = L.map('leaflet-map', {
                zoomSnap: 0.25,
                zoomDelta: 0.25,
                zoomControl: false, // Disable default zoom control
                attributionControl: false // Disable default attribution
            }).setView([selectedGameArea.fixedLatitude, selectedGameArea.initialCenterLng], selectedGameArea.zoom);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, minZoom: 2, attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map);

            // L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            //   attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/">CARTO</a>',
            //   subdomains: 'abcd',
            //   maxZoom: 19
            // }).addTo(map);

            // L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', {
            //   attribution: '&copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, &copy; <a href="http://stamen.com">Stamen Design</a>',
            //   maxZoom: 20
            // }).addTo(map);

            // L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            //   attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/">CARTO</a>',
            //   subdomains: 'abcd',
            //   maxZoom: 19
            // }).addTo(map);

            // --- Custom Zoom Control Listeners ---
            document.getElementById('custom-zoom-in').addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                map.zoomIn();
            });
            document.getElementById('custom-zoom-out').addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                map.zoomOut();
            });

            // Calculate initial plane geo-location
            planeGeoLocation = map.containerPointToLatLng(L.point(plane.x + plane.width / 2, plane.y + plane.height / 2));

            // Variables to handle zoom behavior gracefully
            let zoomAnchorLatLng = null;
            map.on('zoomstart', function() {
                // Calculate the pixel point that should remain "fixed" relative to the plane's crosshair/ground point
                const currentGroundOffsetY = BASE_GROUND_OFFSET_Y * Math.pow(2, (BASE_ZOOM_FOR_GROUND_OFFSET - map.getZoom()));
                const crosshairPoint = L.point(plane.x + plane.width / 2, plane.y + currentGroundOffsetY);
                zoomAnchorLatLng = map.containerPointToLatLng(crosshairPoint);
            });
            map.on('zoomend', function() {
                if (!zoomAnchorLatLng) return; // Exit if no anchor point
                const newScreenPosOfAnchor = map.latLngToContainerPoint(zoomAnchorLatLng); // Get new screen position of anchor
                const newGroundOffsetY = BASE_GROUND_OFFSET_Y * Math.pow(2, (BASE_ZOOM_FOR_GROUND_OFFSET - map.getZoom()));
                const desiredCrosshairScreenPos = L.point(plane.x + plane.width / 2, plane.y + newGroundOffsetY);
                const offset = newScreenPosOfAnchor.subtract(desiredCrosshairScreenPos); // Calculate pixel offset needed
                map.panBy(offset, { animate: false }); // Pan map to correct position

                // Recalculate plane geo-location based on new map view
                const planeScreenCenter = L.point(plane.x + plane.width / 2, plane.y + plane.height / 2);
                planeGeoLocation = map.containerPointToLatLng(planeScreenCenter);
                zoomAnchorLatLng = null; // Reset anchor
            });

            // Enable map interactions
            map.dragging.enable(); map.touchZoom.enable(); map.doubleClickZoom.enable(); map.scrollWheelZoom.enable(); map.boxZoom.enable(); map.keyboard.enable();

            // Initialize active targets and sort them by longitude for game end check
            activeTargets = selectedGameArea.targetLatLngs.map(targetData => ({
                latLng: L.latLng(targetData.lat, targetData.lng),
                radiusMeters: targetData.radiusMeters,
                basePoints: targetData.basePoints,
                hit: false,
                marker: null,
                currentIconDiameter: 0
            })).sort((a, b) => a.latLng.lng - b.latLng.lng); // Sort targets by longitude

            // Set the longitude of the last (rightmost) target
            if (activeTargets.length > 0) {
                lastTargetLng = activeTargets[activeTargets.length - 1].latLng.lng;
            } else {
                lastTargetLng = -Infinity; // No targets, game might end immediately or after a short flight
            }

            // Start the game loop
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); } // Cancel any previous animation frame
            gameLoop();
        }

        /**
         * The main game loop that updates game state and redraws the canvas.
         */
        function gameLoop() {
            if (currentGameState !== GAME_STATES.PLAYING) return; // Only run if playing
            update(); // Update game logic
            draw();   // Redraw game elements
            animationFrameId = requestAnimationFrame(gameLoop); // Request next frame
        }

        /**
         * Updates the game state, including plane movement, bomb physics,
         * target interaction, and map scrolling.
         */
        function update() {
            // Plane vertical movement and map scrolling thresholds
            const PLANE_VERTICAL_SCROLL_UPPER_THRESHOLD = canvas.height * 0.2;
            const PLANE_VERTICAL_SCROLL_LOWER_THRESHOLD = canvas.height * 0.8 - plane.height;
            let verticalMapScrollPixelDelta = 0;

            // Keyboard input for plane vertical movement
            if (keysPressed['ArrowUp'] || keysPressed['KeyW']) {
                if (plane.y > PLANE_VERTICAL_SCROLL_UPPER_THRESHOLD) {
                    plane.y = Math.max(0, plane.y - PLANE_SPEED_Y);
                } else {
                    verticalMapScrollPixelDelta -= PLANE_SPEED_Y;
                }
            } else if (keysPressed['ArrowDown'] || keysPressed['KeyS']) {
                if (plane.y < PLANE_VERTICAL_SCROLL_LOWER_THRESHOLD) {
                    plane.y = Math.min(canvas.height - plane.height, plane.y + PLANE_SPEED_Y);
                } else {
                    verticalMapScrollPixelDelta += PLANE_SPEED_Y;
                }
            } else if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) {
                map.zoomOut();

            } else if (keysPressed['ArrowRight'] || keysPressed['KeyD']) {
                map.zoomIn();
            }

            // Touch input for plane vertical movement
            if (touchIsActive) {
                const deltaY = touchCurrentY - touchLastMoveY; // Calculate vertical movement from touch
                // Adjust plane position or trigger map scroll based on thresholds
                if (plane.y + deltaY < PLANE_VERTICAL_SCROLL_UPPER_THRESHOLD) {
                    verticalMapScrollPixelDelta += (plane.y + deltaY) - PLANE_VERTICAL_SCROLL_UPPER_THRESHOLD;
                    plane.y = PLANE_VERTICAL_SCROLL_UPPER_THRESHOLD;
                } else if (plane.y + deltaY > PLANE_VERTICAL_SCROLL_LOWER_THRESHOLD) {
                    verticalMapScrollPixelDelta += (plane.y + deltaY) - PLANE_VERTICAL_SCROLL_LOWER_THRESHOLD;
                    plane.y = PLANE_VERTICAL_SCROLL_LOWER_THRESHOLD;
                } else {
                    plane.y += deltaY;
                }
                touchLastMoveY = touchCurrentY; // Update last touch Y position
            }

            // Clamp plane's Y position to stay within canvas bounds
            plane.y = Math.min(Math.max(0, plane.y), canvas.height - plane.height);

            // Update plane's geo-location based on its screen position
            const planeScreenCenter = L.point(plane.x + plane.width / 2, plane.y + plane.height / 2);
            planeGeoLocation = map.containerPointToLatLng(planeScreenCenter);

            // Simulate horizontal map scrolling (plane flying forward)
            mapScrollXProgress += MAP_SCROLL_SPEED_METERS_PER_FRAME;
            const initialProjectedOriginX = map.options.crs.project(L.latLng(planeGeoLocation.lat, selectedGameArea.initialCenterLng)).x;
            const currentProjectedPlaneLngX = initialProjectedOriginX + mapScrollXProgress;
            planeGeoLocation.lng = map.options.crs.unproject(L.point(currentProjectedPlaneLngX, map.options.crs.project(planeGeoLocation).y)).lng;

            // Adjust map view to keep the plane centered horizontally and handle vertical scroll
            const mapCenterPixelFromPlaneGeo = map.latLngToContainerPoint(planeGeoLocation);
            const idealMapCenterPixelX = mapCenterPixelFromPlaneGeo.x - (planeScreenCenter.x - (canvas.width / 2));
            const idealMapCenterPixelY = mapCenterPixelFromPlaneGeo.y - (planeScreenCenter.y - (canvas.height / 2));
            const finalMapCenterPixelY = idealMapCenterPixelY + verticalMapScrollPixelDelta;
            const finalTargetMapCenterGeo = map.containerPointToLatLng(L.point(idealMapCenterPixelX, finalMapCenterPixelY));

            map.setView(finalTargetMapCenterGeo, map.getZoom(), { animate: false });

            // Update bombs' positions and check for ground hits
            bombs.forEach((bomb, index) => {

                bomb.velocityY += BOMB_GRAVITY; // Apply gravity

                bomb.y += bomb.velocityY;       // Update bomb position

                // TODO: This needs to be the plans original height, not the current height

                const groundHitY = bomb.originalY + dynamicGroundOffsetY; // Calculate ground level in pixels

                // Check if bomb hits the ground
                if (bomb.y >= groundHitY - bomb.height / 2) {

                    // TODO: we need to stop the dropping sound here
                    bombDropSound.pause(); // Stop the bomb drop sound

                    const bombLandingPointX = bomb.x + bomb.width / 2;
                    const bombLandingPointY = groundHitY - bomb.height / 2 ;
                    let hitDetected = false;

                    const impactLatLng = map.containerPointToLatLng(L.point(bombLandingPointX, bombLandingPointY));

                    const craterIcon = L.divIcon({
                        className: 'crater-marker',
                        iconSize: [20, 20], // The size of the crater
                        iconAnchor: [10, 10]
                    });

                    const targetProjectedPoint = map.options.crs.project(impactLatLng);

                    const pointAtRadiusEast = L.point(targetProjectedPoint.x , targetProjectedPoint.y);
                    const latLngAtRadiusEast = map.options.crs.unproject(pointAtRadiusEast);

                    // console.log("Bomb index",index)
                    // console.log("Crater impact at:", impactLatLng, bombLandingPointX, bombLandingPointY, latLngAtRadiusEast); // Debug log for crater impact

                    // Create and add the crater marker to the map
                    const craterMarker = L.marker(latLngAtRadiusEast, { icon: craterIcon, zIndexOffset: 10 }).addTo(map);

                    // Remove crater after a delay
                    // setTimeout(() => {
                    //     if (map) {
                    //        map.removeLayer(craterMarker);
                    //     }
                    // }, 27000); // 7 seconds
                    // --- END NEW CRATER CODE ---

                    // Check for hits on active targets
                    activeTargets.forEach(target => {

                        if (!target.hit && target.marker) { // Only check unhit targets with visible markers

                            const targetCenterPixel = map.latLngToContainerPoint(target.latLng); // Get target's screen position

                            // Get target's visual radius from its marker icon
                            const targetVisualRadius = target.marker._icon ? target.marker._icon.offsetWidth / 2 : 0;

                            // Calculate distance from bomb landing point to target center
                            const pixelDistance = Math.sqrt(Math.pow(bombLandingPointX - targetCenterPixel.x, 2) + Math.pow(bombLandingPointY - targetCenterPixel.y, 2));

                            // If bomb lands within target's visual radius
                            if (targetVisualRadius > 0 && pixelDistance <= targetVisualRadius) {
                                const proximityScoreFactor = 1 - (pixelDistance / targetVisualRadius); // Closer to center = more points
                                score += Math.round(target.basePoints * proximityScoreFactor); // Add score
                                hits++;          // Increment hits
                                target.hit = true; // Mark target as hit

                                // map.removeLayer(target.marker); // Remove target marker from map

                                // target.marker.options.icon.options.className.add('target-hit'); // Change marker class to indicate hit

                                target.marker._icon.classList.add('target-hit'); // Add hit class to marker icon
                                console.log(`Hit target at ${target.latLng} with score: ${target.basePoints * proximityScoreFactor}`); // Debug log for hit
                                hitDetected = true; // Set hit flag

                            }
                        }
                    });

                    if (!hitDetected) {
                        misses++;
                        explosionSound.volume=0.4
                    } else{
                        explosionSound.volume=1
                    }

                    playSound(explosionSound); // Play explosion sound

                    explosions.push({ x: bombLandingPointX, y: groundHitY, frame: 0 }); // Create an explosion effect
                    bombs.splice(index, 1); // Remove the bomb
                    updateScoreDisplay(); // Update score display
                }

            });

            // Update explosions and remove expired ones
            explosions.forEach((explosion, index) => {
                explosion.frame++;
                if (explosion.frame > EXPLOSION_DURATION) { explosions.splice(index, 1); }
            });

            // Adjust dynamic ground offset based on map zoom level to simulate perspective
            dynamicGroundOffsetY = BASE_GROUND_OFFSET_Y * Math.pow(2, (BASE_ZOOM_FOR_GROUND_OFFSET - map.getZoom()));
            dynamicGroundOffsetY = Math.max(20, dynamicGroundOffsetY); // Ensure a minimum offset

            // Update target markers (visibility and size based on zoom)

            const currentMapBounds = map.getBounds();

            activeTargets.forEach(target => {
                if (!target.hit) { // Only process unhit targets
                    if (currentMapBounds.contains(target.latLng)) { // If target is within current map view
                        // Calculate pixel radius of the target based on its real-world radius and current map scale
                        const targetProjectedPoint = map.options.crs.project(target.latLng);
                        const pointAtRadiusEast = L.point(targetProjectedPoint.x + target.radiusMeters, targetProjectedPoint.y);
                        const latLngAtRadiusEast = map.options.crs.unproject(pointAtRadiusEast);
                        const targetPixelPoint = map.latLngToContainerPoint(target.latLng);
                        const radiusEastPixelPoint = map.latLngToContainerPoint(latLngAtRadiusEast);
                        const pixelRadius = targetPixelPoint.distanceTo(radiusEastPixelPoint);
                        const newIconDiameter = Math.max(16, pixelRadius * 2); // Minimum diameter for visibility

                        if (!target.marker) { // If marker doesn't exist, create it
                            const targetIcon = L.divIcon({ className: 'target-icon', html: `<div style="width:${newIconDiameter}px; height:${newIconDiameter}px; line-height:${newIconDiameter - 4}px;">X</div>`, iconSize: [newIconDiameter, newIconDiameter], iconAnchor: [newIconDiameter / 2, newIconDiameter / 2] });
                            target.marker = L.marker(target.latLng, { icon: targetIcon }).addTo(map);
                            target.currentIconDiameter = newIconDiameter;
                        } else if (target.currentIconDiameter !== newIconDiameter) { // If diameter changed, update icon
                            const updatedIcon = L.divIcon({ className: 'target-icon', html: `<div style="width:${newIconDiameter}px; height:${newIconDiameter}px; line-height:${newIconDiameter - 4}px;">X</div>`, iconSize: [newIconDiameter, newIconDiameter], iconAnchor: [newIconDiameter / 2, newIconDiameter / 2] });
                            target.marker.setIcon(updatedIcon);
                            target.currentIconDiameter = newIconDiameter;
                        }
                    } else {
                        // If target is outside map bounds, remove its marker if it exists
                        if (target.marker) {
                            map.removeLayer(target.marker);
                            target.marker = null;
                            delete target.currentIconDiameter;
                        }
                    }
                }
            });

            // NEW GAME END CONDITION: Game ends when the last target passes off the left side of the screen
            let allTargetsPassed = true;
            if (activeTargets.length > 0) {
                // Get the pixel position of the last (rightmost) target.
                // We assume targets are sorted by longitude, so the last one is the "furthest" along the flight path.
                const lastTarget = activeTargets[activeTargets.length - 1];
                if (!lastTarget.hit) { // Only check if the last target hasn't been hit
                    const lastTargetScreenPoint = map.latLngToContainerPoint(lastTarget.latLng);
                    // If the last target is still visible on screen or to the right of the plane's x-position
                    // then the game has not ended yet.
                    if (lastTargetScreenPoint.x > plane.x - (plane.width / 2)) {
                        allTargetsPassed = false;
                    }
                }
            } else {
                // If there are no targets, the game can end after a short duration or immediately,
                // but for now, we'll let it continue until bombs/explosions clear.
                // This scenario should be rare with pre-defined areas.
            }

            // End the game if all targets have been passed/hit and no bombs or explosions are active
            if (allTargetsPassed && bombs.length === 0 && explosions.length === 0) {
                endGame();
            }

            updateScoreDisplay(); // Always update score display
        }

        /**
         * Draws all game elements on the canvas, including the plane, bombs,
         * and explosions.
         */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            // Draw the plane with rotation
            ctx.save(); // Save canvas state
            ctx.translate(plane.x + plane.width / 2, plane.y + plane.height / 2); // Move origin to plane center
            ctx.rotate(plane.tiltAngle); // Apply plane tilt
            ctx.fillStyle = '#2d3748'; // Plane body color
            ctx.beginPath(); // Start drawing plane shape
            ctx.moveTo(plane.width / 2, 0);
            ctx.lineTo(plane.width * 0.2, -plane.height / 2);
            ctx.lineTo(-plane.width / 2, -plane.height * 1.0);
            ctx.lineTo(-plane.width / 2, plane.height * 1.0);
            ctx.lineTo(plane.width * 0.2, plane.height / 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#a0aec0'; // Cockpit color
            ctx.fillRect(plane.width * 0.3, -2.5, 8, 5); // Cockpit rectangle
            ctx.restore(); // Restore canvas state (undo translation and rotation)

            // Draw bombs
            bombs.forEach(bomb => {
                // Scale bombs based on their distance to the ground for a pseudo-3D effect
                const dropDistance = bomb.y - (plane.y + plane.height);
                const totalFallDistance = (plane.y + dynamicGroundOffsetY) - (plane.y + plane.height);
                let scaleFactor = 1 - (dropDistance / totalFallDistance * 0.9); // Scale diminishes as bomb falls
                scaleFactor = Math.max(0.1, Math.min(1, scaleFactor)); // Clamp scale factor

                const scaledWidth = bomb.width * scaleFactor;
                const scaledHeight = bomb.height * scaleFactor;
                const drawX = bomb.x + (bomb.width - scaledWidth) / 2; // Center scaled bomb
                const drawY = bomb.y;
                ctx.fillStyle = '#4a5568'; // Bomb body color
                ctx.fillRect(drawX, drawY, scaledWidth, scaledHeight);
                ctx.fillStyle = '#cbd5e1'; // Bomb fin color
                ctx.beginPath();
                ctx.moveTo(drawX, drawY + scaledHeight);
                ctx.lineTo(drawX + scaledWidth, drawY + scaledHeight);
                ctx.lineTo(drawX + scaledWidth / 2, drawY + scaledHeight + (scaledHeight / 2)); // Triangle for fins
                ctx.closePath();
                ctx.fill();
            });


            // Draw explosions
            // These should drawn on the map not the canvas

            explosions.forEach(explosion => {
                const opacity = 1 - (explosion.frame / EXPLOSION_DURATION); // Fade out over time
                const radius = (explosion.frame / EXPLOSION_DURATION) * 40; // Grow over time

                ctx.fillStyle = `rgba(255, 165, 0, ${opacity})`; // Orange outer glow
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = `rgba(255, 69, 0, ${opacity * 0.7})`; // Reddish inner glow
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius * 0.7, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = `rgba(255, 169, 0, ${opacity * 0.3})`; // Reddish inner glow
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius * 1.3, 0, Math.PI * 2);
                ctx.fill();

            });

            // Draw shadow of the plane (small opaque triangle) pointing to the right
            if (currentGameState === GAME_STATES.PLAYING) {
                const shadowX = plane.x + plane.width / 2; // Position shadow to the below the plane
                const shadowY = plane.y + dynamicGroundOffsetY; // Position shadow at calculated ground level

                const shadowWidth = 20; // Width of the shadow triangle
                const shadowHeight = 10; // Height of the shadow triangle

                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Semi-transparent black for shadow
                ctx.beginPath();
                ctx.moveTo(shadowX+10, shadowY); // Left point of the triangle
                ctx.lineTo(shadowX - shadowWidth, shadowY - shadowHeight / 2); // Top point
                ctx.lineTo(shadowX - shadowWidth, shadowY + shadowHeight / 2); // Bottom point
                ctx.closePath();
                ctx.fill();

            }
        }

        /**
         * Updates the score display text.
         */
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score} | Hits: ${hits} | Misses: ${misses}`;
        }

        /**
         * Ends the game, displays the game over modal, and prepares for debriefing.
         */
        function endGame() {
            currentGameState = GAME_STATES.GAME_OVER; // Set game state to game over
            cancelAnimationFrame(animationFrameId);    // Stop the game loop

            gameOverTitle.textContent = 'Game Over!';
            finalScoreDisplay.textContent = `Final Score: ${score}`;
            proximityResultsDisplay.textContent = `Targets Hit: ${hits} | Bombs Missed: ${misses}`;
            showModal(gameOverModal); // Show game over modal

            // Event listener for getting debriefing from Gemini API
            getDebriefingButton.onclick = () => {
                const prompt = `Generate a concise, encouraging, or reflective debriefing for a pilot who completed a bombing mission. Their final score was ${score} points, with ${hits} targets hit and ${misses} bombs missed. Suggest an improvement or a highlight based on their performance. Keep it under 100 words.`;
                callGeminiAPI(prompt, debriefingOutput, debriefingLoadingSpinner);
            };
        }

        function showModal(modalElement) {
            modalElement.classList.remove('hidden');
        }
        function hideModal(modalElement) {
            modalElement.classList.add('hidden');
        }

        // Initialize the game when the window loads
        window.onload = function() {
            initGame();
        };
    </script>
</body>
</html>
